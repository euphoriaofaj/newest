<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket + WebRTC Signaling Test</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #ccc; border-radius: 5px; }
        .log { height: 200px; overflow-y: scroll; border: 1px solid #ddd; padding: 10px; background: #f9f9f9; margin: 10px 0; }
        input, button { margin: 5px; padding: 8px; }
        button { background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .connected { background: #d4edda; color: #155724; }
        .disconnected { background: #f8d7da; color: #721c24; }
        .message-received { background: #e2f3ff; margin: 5px 0; padding: 5px; border-radius: 3px; }
        .webrtc-section { background: #f8f9fa; }
        .call-controls { margin: 10px 0; }
        .call-controls button { margin-right: 10px; }
    </style>
</head>
<body>
<div class="container">
    <h1>WebSocket + WebRTC Signaling Test</h1>

    <div class="section">
        <h2>Connection Status</h2>
        <div id="status" class="status disconnected">Disconnected</div>
        <button onclick="connect()">Connect</button>
        <button onclick="disconnect()">Disconnect</button>
    </div>

    <div class="section webrtc-section">
        <h2>WebRTC Signaling Testing</h2>
        <div>
            <input type="text" id="callId" placeholder="Call ID" value="call_123">
            <input type="text" id="localUserId" placeholder="Local User ID" value="user1">
            <input type="text" id="remoteUserId" placeholder="Remote User ID" value="user2">
        </div>
        <div class="call-controls">
            <button onclick="initializePeerConnection()">Initialize Peer Connection</button>
            <button onclick="createOffer()">Create Offer</button>
            <button onclick="endCall()">End Call</button>
        </div>
        <div>
            <h4>WebRTC Logs:</h4>
            <div id="webrtcLog" class="log"></div>
        </div>
    </div>

    <div class="section">
        <h2>Call Notifications Testing</h2>
        <div>
            <input type="text" id="callerId" placeholder="Caller ID" value="caller1">
            <input type="text" id="recipientId" placeholder="Recipient ID" value="recipient1">
            <input type="text" id="themeId" placeholder="Theme ID" value="1">
        </div>
        <div class="call-controls">
            <button onclick="sendIncomingCall()">Send Incoming Call</button>
            <button onclick="sendCallEnd()">Send Call End</button>
            <button onclick="sendCallCancel()">Send Call Cancel</button>
        </div>
        <div>
            <h4>Call Notification Logs:</h4>
            <div id="callLog" class="log"></div>
        </div>
    </div>

    <div class="section">
        <h2>All Messages Log</h2>
        <div id="allMessagesLog" class="log"></div>
        <button onclick="clearLogs()">Clear Logs</button>
    </div>
</div>

<script>
    let stompClient = null;
    let pc;
    let currentUserId = 'testUser_' + Math.floor(Math.random()*1000);

    function connect() {
        const socket = new SockJS('http://localhost:8080/ws');
        stompClient = Stomp.over(socket);
        stompClient.connect({'user': currentUserId}, frame => {
            updateStatus('Connected as: '+currentUserId, true);
            log('Connected: '+frame);

            // Subscribe to WebRTC signals
            stompClient.subscribe('/user/queue/webrtc-signals', msg => handleSignalingMessage(JSON.parse(msg.body)));

            // Subscribe to call notifications
            stompClient.subscribe('/user/queue/call-notifications', msg => handleCallNotification(JSON.parse(msg.body)));

            // Subscribe to WebRTC room updates
            const callId = document.getElementById('callId').value;
            stompClient.subscribe('/topic/webrtc-room/' + callId, msg => handleWebRTCRoomMessage(JSON.parse(msg.body)));

        }, error => { updateStatus('Connection failed: '+error,false); log('Connection error: '+error); });
    }

    function disconnect() {
        if(stompClient) stompClient.disconnect();
        updateStatus('Disconnected',false);
        log('Disconnected from WebSocket');
    }

    function initializePeerConnection() {
        const callId = document.getElementById('callId').value;
        if(stompClient && stompClient.connected) {
            stompClient.send('/app/webrtc.init/' + callId, {}, JSON.stringify({}));
            logWebRTC('Peer connection initialization sent for call: ' + callId);
        }
    }

    function createOffer() {
        const callId = document.getElementById('callId').value;
        const localUserId = document.getElementById('localUserId').value;
        const remoteUserId = document.getElementById('remoteUserId').value;

        pc = new RTCPeerConnection();
        pc.onicecandidate = event => {
            if(event.candidate && stompClient && stompClient.connected) {
                const iceMessage = {
                    callId: callId,
                    fromUserId: localUserId,
                    toUserId: remoteUserId,
                    candidate: event.candidate,
                    type: 'ICE_CANDIDATE'
                };
                stompClient.send('/app/webrtc.ice', {}, JSON.stringify(iceMessage));
                logWebRTC('ICE candidate sent');
            }
        };
        pc.createOffer().then(offer => {
            pc.setLocalDescription(offer);
            const offerMessage = {
                callId: callId,
                fromUserId: localUserId,
                toUserId: remoteUserId,
                sdp: offer,
                type: 'OFFER'
            };
            stompClient.send('/app/webrtc.offer', {}, JSON.stringify(offerMessage));
            logWebRTC('Offer created and sent via WebSocket');
        });
    }

    function endCall() {
        const callId = document.getElementById('callId').value;
        if(stompClient && stompClient.connected) {
            stompClient.send('/app/webrtc.close/' + callId, {}, JSON.stringify({}));
            logWebRTC('Call ended for: ' + callId);
        }
        if(pc) {
            pc.close();
            pc = null;
        }
    }

    function sendIncomingCall() {
        const callMessage = {
            id: 'call_' + Date.now(),
            callId: document.getElementById('callId').value,
            callerId: document.getElementById('callerId').value,
            recipientId: document.getElementById('recipientId').value,
            themeId: document.getElementById('themeId').value,
            type: 'INCOMING_CALL',
            status: 'PENDING'
        };

        if(stompClient && stompClient.connected) {
            stompClient.send('/app/call.notify.incoming', {}, JSON.stringify(callMessage));
            logCall('Incoming call notification sent');
        }
    }

    function sendCallEnd() {
        const callMessage = {
            callId: document.getElementById('callId').value,
            type: 'CALL_ENDED'
        };

        if(stompClient && stompClient.connected) {
            stompClient.send('/app/call.notify.end', {}, JSON.stringify(callMessage));
            logCall('Call end notification sent');
        }
    }

    function sendCallCancel() {
        const callMessage = {
            callId: document.getElementById('callId').value,
            type: 'CALL_CANCELLED'
        };

        if(stompClient && stompClient.connected) {
            stompClient.send('/app/call.notify.cancel', {}, JSON.stringify(callMessage));
            logCall('Call cancel notification sent');
        }
    }

    function handleSignalingMessage(data) {
        logWebRTC('Received signaling message: ' + JSON.stringify(data));

        if(!pc) pc = new RTCPeerConnection();
        if(data.sdp) {
            const desc = new RTCSessionDescription(data.sdp);
            pc.setRemoteDescription(desc).then(() => {
                logWebRTC('SDP set from remote');
                if(desc.type==='offer') pc.createAnswer().then(answer=>{
                    pc.setLocalDescription(answer);
                    const answerMessage = {
                        callId: data.callId,
                        fromUserId: document.getElementById('localUserId').value,
                        toUserId: data.fromUserId,
                        sdp: answer,
                        type: 'ANSWER'
                    };
                    stompClient.send('/app/webrtc.answer', {}, JSON.stringify(answerMessage));
                    logWebRTC('Answer sent via WebSocket');
                });
            });
        } else if(data.candidate) {
            pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            logWebRTC('ICE candidate added from remote');
        }
    }

    function handleCallNotification(data) {
        logCall('Received call notification: ' + JSON.stringify(data));
    }

    function handleWebRTCRoomMessage(data) {
        logWebRTC('Room message: ' + JSON.stringify(data));
    }

    function updateStatus(msg,connected) {
        const statusDiv = document.getElementById('status');
        statusDiv.textContent=msg;
        statusDiv.className='status '+(connected?'connected':'disconnected');
    }

    function log(msg) {
        const logDiv=document.getElementById('allMessagesLog');
        const timestamp=new Date().toLocaleTimeString();
        logDiv.innerHTML+=`[${timestamp}] ${msg}<br>`;
        logDiv.scrollTop=logDiv.scrollHeight;
    }

    function logWebRTC(msg) {
        const logDiv=document.getElementById('webrtcLog');
        const timestamp=new Date().toLocaleTimeString();
        logDiv.innerHTML+=`[${timestamp}] ${msg}<br>`;
        logDiv.scrollTop=logDiv.scrollHeight;
    }

    function logCall(msg) {
        const logDiv=document.getElementById('callLog');
        const timestamp=new Date().toLocaleTimeString();
        logDiv.innerHTML+=`[${timestamp}] ${msg}<br>`;
        logDiv.scrollTop=logDiv.scrollHeight;
    }

    function clearLogs() {
        document.getElementById('allMessagesLog').innerHTML='';
        document.getElementById('webrtcLog').innerHTML='';
        document.getElementById('callLog').innerHTML='';
    }
</script>
</body>
</html>